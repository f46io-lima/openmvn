image: docker:latest

services:
  - name: docker:dind
    command: ["--tls=false"]
    alias: docker

variables:
  # Use tcp://docker:2376 for TLS or tcp://docker:2375 for non-TLS
  DOCKER_HOST: tcp://localhost:2375
  DOCKER_TLS_CERTDIR: ""  # Disable TLS
  DOCKER_DRIVER: overlay2
  # Add these to help with DinD setup
  DOCKER_BUILDKIT: 1
  DOCKER_CLI_EXPERIMENTAL: enabled
  # Service variables
  REDIS_ADDR: redis:6379
  NATS_URL: nats://nats:4222
  # Use dynamic port for SMF to avoid conflicts
  SMF_PORT: ${SMF_PORT:-8805}
  AMF_PORT: 8081
  OCS_PORT: 8082
  UDM_PORT: 8083
  BSS_PORT: 8084

stages:
  - build
  - test
  - push

before_script:
  # Install required packages
  - apk add --no-cache go git curl bash
  # Generate random port for SMF if not set
  - |
    if [ -z "$SMF_PORT" ]; then
      # Generate a random port between 10000 and 65000
      export SMF_PORT=$(( (RANDOM % 55000) + 10000 ))
      echo "Using dynamic SMF port: $SMF_PORT"
    fi
  # Wait for Docker daemon to be ready
  - |
    for i in $(seq 1 30); do
      if docker info > /dev/null 2>&1; then
        break
      fi
      echo "Waiting for Docker daemon... attempt $i"
      sleep 2
    done
  # Login to registry only if credentials are available
  - |
    if [ -n "$CI_REGISTRY_PASSWORD" ] && [ -n "$CI_REGISTRY_USER" ] && [ -n "$CI_REGISTRY" ]; then
      echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    else
      echo "Skipping registry login - credentials not available"
    fi
  # Cleanup
  - docker ps -aq | xargs -r docker rm -f || true
  - docker network prune -f || true

build_services:
  stage: build
  script:
    - docker-compose build
  artifacts:
    paths:
      - ./*/Dockerfile
      - docker-compose.yml

unit_tests:
  stage: test
  services:
    - name: redis:7-alpine
      alias: redis
    - name: nats:2.10.11-alpine
      alias: nats
      command: ["-js"]
  script:
    - for svc in amf smf ocs upf bss; do
        cd $svc;
        go mod tidy;
        go test -v ./...;
        cd ..;
      done
  artifacts:
    reports:
      junit: junit-*.xml
    when: always

integration_test:
  stage: test
  script:
    # Start infrastructure services first
    - docker-compose up -d redis nats
    - sleep 5  # Wait for services to start
    
    # Export environment variables for docker-compose
    - export SMF_PORT=$SMF_PORT
    - export AMF_PORT=$AMF_PORT
    - export OCS_PORT=$OCS_PORT
    - export UDM_PORT=$UDM_PORT
    - export BSS_PORT=$BSS_PORT
    
    # Start all services
    - docker-compose up -d
    
    - sleep 10  # Wait for all services to start
    
    # Check health endpoints
    - |
      for port in $AMF_PORT $OCS_PORT $UDM_PORT $BSS_PORT; do
        echo "Checking health on port $port..."
        curl -f http://localhost:$port/health || exit 1
      done
    
    # Check SMF PFCP port with dynamic port
    - |
      echo "Checking SMF PFCP port $SMF_PORT..."
      nc -z localhost $SMF_PORT || exit 1
    
    # Log the actual port being used
    - echo "SMF is running on port $SMF_PORT"
    - docker-compose logs
  allow_failure: false
  after_script:
    - docker-compose down -v --remove-orphans
    - docker ps -aq | xargs -r docker rm -f || true
    - docker network prune -f || true
  artifacts:
    when: on_failure
    paths:
      - docker-compose.log

push_images:
  stage: push
  script:
    - |
      for svc in amf smf ocs upf bss; do
        echo "Pushing $svc..."
        docker tag openmvcore_$svc "$CI_REGISTRY_IMAGE/$svc:latest"
        docker tag openmvcore_$svc "$CI_REGISTRY_IMAGE/$svc:$CI_COMMIT_SHA"
        docker push "$CI_REGISTRY_IMAGE/$svc:latest"
        docker push "$CI_REGISTRY_IMAGE/$svc:$CI_COMMIT_SHA"
      done
  only:
    - main
  when: manual
