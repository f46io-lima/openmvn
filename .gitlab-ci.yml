image: docker:24.0.2

services:
  - name: docker:24.0.2-dind
    command: ["--tls=false"]
    alias: docker

variables:
  # Use tcp://docker:2376 for TLS or tcp://docker:2375 for non-TLS
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""  # Disable TLS
  DOCKER_DRIVER: overlay2
  # Add these to help with DinD setup
  DOCKER_BUILDKIT: 1
  DOCKER_CLI_EXPERIMENTAL: enabled
  # Service variables
  REDIS_ADDR: redis:6379
  NATS_URL: nats://nats:4222
  # Use dynamic port for SMF to avoid conflicts
  SMF_PORT: ${SMF_PORT:-8805}
  AMF_PORT: 8081
  OCS_PORT: 8082
  UDM_PORT: 8083
  BSS_PORT: 8084
  # Testcontainers settings
  TESTCONTAINERS_RYUK_DISABLED: "true"
  TESTCONTAINERS_DOCKER_SOCKET_OVERRIDE: "/var/run/docker.sock"

stages:
  - build
  - test
  - integration-test
  - push
  - deploy

before_script:
  # Install required packages
  - apk add --no-cache go git curl bash
  # Generate random port for SMF if not set
  - |
    if [ -z "$SMF_PORT" ]; then
      # Generate a random port between 10000 and 65000
      export SMF_PORT=$(( (RANDOM % 55000) + 10000 ))
      echo "Using dynamic SMF port: $SMF_PORT"
    fi
  # Wait for Docker daemon to be ready
  - |
    for i in $(seq 1 30); do
      if docker info > /dev/null 2>&1; then
        break
      fi
      echo "Waiting for Docker daemon... attempt $i"
      sleep 2
    done
  # Login to registry only if credentials are available
  - |
    if [ -n "$CI_REGISTRY_PASSWORD" ] && [ -n "$CI_REGISTRY_USER" ] && [ -n "$CI_REGISTRY" ]; then
      echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
    else
      echo "Skipping registry login - credentials not available"
    fi
  # Cleanup
  - docker ps -aq | xargs -r docker rm -f || true
  - docker network prune -f || true

build_services:
  stage: build
  script:
    - docker-compose build
  artifacts:
    paths:
      - ./*/Dockerfile
      - docker-compose.yml

unit_tests:
  stage: test
  services:
    - name: redis:7-alpine
      alias: redis
    - name: nats:2.10.11-alpine
      alias: nats
      command: ["-js"]
  script:
    - |
      for svc in amf smf ocs upf bss imsi-manager imsi-switch-receiver; do
        cd $svc
        go mod tidy
        go test -v -race -coverprofile=coverage.txt -covermode=atomic ./...
        # Upload coverage report
        curl -s https://codecov.io/bash | bash -s -- -f coverage.txt -t $CODECOV_TOKEN
        cd ..
      done
  coverage: '/coverage: \d+\.\d+% of statements/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: "**/coverage.txt"

integration_tests:
  stage: integration-test
  image: golang:1.21
  services:
    - name: docker:dind
      alias: docker
      command: ["--tls=false"]
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  before_script:
    - apk add --no-cache docker-cli
    - go install github.com/codecov/codecov-go@latest
  script:
    - |
      cd integration_test
      go mod tidy
      go test -v -race -coverprofile=coverage.integration.txt -covermode=atomic ./...
      # Upload integration coverage report
      curl -s https://codecov.io/bash | bash -s -- -f coverage.integration.txt -t $CODECOV_TOKEN
  coverage: '/coverage: \d+\.\d+% of statements/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: "**/coverage.integration.txt"
    when: on_failure
    paths:
      - integration_test/*.log
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request"
      when: manual
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: on_success

kaniko_push:
  image: gcr.io/kaniko-project/executor:latest
  stage: push
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_CLI_EXPERIMENTAL: enabled
  before_script:
    - echo "ðŸ” Authenticating Kaniko to Docker registry..."
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
  script:
    - |
      # Extract version from tag if available
      VERSION=${CI_COMMIT_TAG:-$CI_COMMIT_SHA}
      echo "ðŸ“¦ Building version: $VERSION"
      
      for svc in amf smf ocs upf bss imsi-manager imsi-switch-receiver; do
        echo "ðŸ“¦ Pushing $svc with Kaniko..."
        /kaniko/executor \
          --context "$CI_PROJECT_DIR/$svc" \
          --dockerfile "$CI_PROJECT_DIR/$svc/Dockerfile" \
          --destination "$CI_REGISTRY_IMAGE/$svc:$VERSION" \
          --destination "$CI_REGISTRY_IMAGE/$svc:latest" \
          --cache=true \
          --cache-ttl=24h \
          --push-retry=3 \
          --log-format=text \
          --log-timestamp
      done
  rules:
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/
      when: on_success
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
  after_script:
    - echo "âœ… Push completed for version: $VERSION"
  artifacts:
    reports:
      dotenv: build.env
    expire_in: 1 week
    when: on_success

# Keep the existing push_images job for backward compatibility
push_images:
  stage: push
  script:
    - |
      for svc in amf smf ocs upf bss imsi-manager imsi-switch-receiver; do
        echo "Pushing $svc..."
        docker tag openmvcore_$svc "$CI_REGISTRY_IMAGE/$svc:latest"
        docker tag openmvcore_$svc "$CI_REGISTRY_IMAGE/$svc:$CI_COMMIT_SHA"
        docker push "$CI_REGISTRY_IMAGE/$svc:latest"
        docker push "$CI_REGISTRY_IMAGE/$svc:$CI_COMMIT_SHA"
      done
  only:
    - main
  when: manual
  allow_failure: true  # Allow this job to fail since we have kaniko_push
